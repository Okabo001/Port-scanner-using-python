import socket
import threading
import urllib.parse
import requests

def resolve_ip(target):
    """
    Resolves a URL to an IP address. If the input is already an IP address,
    it returns the IP address as-is.
    """
    try:
        parsed_url = urllib.parse.urlparse(target)
        hostname = parsed_url.hostname if parsed_url.hostname else target
        ip = socket.gethostbyname(hostname)
        print(f"Resolved {hostname} to IP address {ip}")
        return ip
    except socket.gaierror:
        print("Invalid URL or IP address.")
        return None


def scan_port(ip, port):
    """
    Scans a specific port on the target IP. If the port is open, checks for potential vulnerabilities.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    try:
        s.connect((ip, port))
        print(f"Port {port} is open on {ip}")
        check_vulnerability(ip, port)
    except (socket.timeout, socket.error):
        pass
    finally:
        s.close()


def check_vulnerability(ip, port):
    """
    Checks for vulnerabilities on specific commonly exposed ports.
    """
    if port == 21:
        print(f"[Warning] Port {port} (FTP) is open. Ensure anonymous access is disabled.")
    elif port == 22:
        print(f"[Info] Port {port} (SSH) is open. Check for strong authentication settings.")
    elif port == 80 or port == 443:
        check_http_security(f"http://{ip}" if port == 80 else f"https://{ip}")


def check_http_security(url):
    """
    Checks for HTTP security headers to identify potential weaknesses.
    """
    try:
        response = requests.get(url, timeout=3)
        headers = response.headers
        missing_headers = []

        # Check for common security headers
        if "X-Content-Type-Options" not in headers:
            missing_headers.append("X-Content-Type-Options")
        if "X-Frame-Options" not in headers:
            missing_headers.append("X-Frame-Options")
        if "Content-Security-Policy" not in headers:
            missing_headers.append("Content-Security-Policy")
        if "Strict-Transport-Security" not in headers and url.startswith("https"):
            missing_headers.append("Strict-Transport-Security")

        if missing_headers:
            print(f"[Vulnerability] {url} is missing security headers: {', '.join(missing_headers)}")
        else:
            print(f"[Secure] {url} has all recommended security headers.")
    except requests.RequestException:
        print(f"[Error] Could not connect to {url} to check HTTP security headers.")


def threaded_scan(ip, start_port, end_port, thread_count=10):
    """
    Scans a range of ports on a target IP address using multiple threads.
    """
    print(f"Scanning {ip} from port {start_port} to {end_port} using {thread_count} threads.")
    threads = []

    for port in range(start_port, end_port + 1):
        thread = threading.Thread(target=scan_port, args=(ip, port))
        threads.append(thread)
        thread.start()

        if len(threads) >= thread_count:
            for t in threads:
                t.join()
            threads.clear()

    for t in threads:
        t.join()


if __name__ == "__main__":
    target = input("Enter the target IP address or URL: ")

    if not target.startswith(('http://', 'https://')):
        target = 'http://' + target

    start_port = int(input("Enter the start port: "))
    end_port = int(input("Enter the end port: "))
    thread_count = int(input("Enter the number of threads (default is 10): ") or 10)

    target_ip = resolve_ip(target)
    if target_ip:
        threaded_scan(target_ip, start_port, end_port, thread_count)
    else:
        print("Could not resolve the target to a valid IP address. Exiting.")
